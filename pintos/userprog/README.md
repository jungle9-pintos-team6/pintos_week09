# 프로젝트 2: 사용자 프로그램

- 사용자 프로그램 실행을 가능하게 하는 시스템 구축해야함
- 기본 코드 지원사항:  프로그램 로드 및 실행
- 미지원 사항: I/O 또는 OS와의 상호작용
- 추가 과제: 선택사항

## 배경

- 테스트 코드를 포함한 지금까지의 모든 코드: 운영체제 커널의 일부였음 = 모든 부분에 접근 권한을 가짐
- 지금부터는 사용자 프로그램을 실행하기 때문에 접근 권한 관련 처리를 해야함.

- 2개 이상의 프로세스가 동시에 실행 될 수 있도록 허용
- 스레드는 각 프로세스별 1개로 제한

- 지금까지는 커널 내에서 특정 함수 인터페이스를 사용해야했으나, 이제는 아님

- 동기화와 가상주소 읽기

## 소스코드

- `process.c`, `process.h`: ELF 바이너리를 로드하고 프로세스를 시작.
- `syscall.c`, `syscall.h`:
    - 사용자 프로세스가 커널 기능을 사용하려고 할 때 시스템 호출을 호출함. 시스템 호출 핸들러의 골격
    - 현재: 메시지를 출력하고 사용자 프로세스를 종료하는 기능만 있음
    - 할것: 추가 기능 구현
- `exception.c`, `exception.h`
    - 사용자 프로세스가 금지된 작업을 수행할 때, exception 또는 fault로 커널에 트랩되는데
    - 이 파일에서 예외를 처리함.
    - 현재: 단순히 메시지 출력 후 프로세스 종료
    - 할것: `page_fault()`를 수정해야함.
- `gdt.c`, `gdt.h`
    - x86-64는 [세그먼트 아키텍처](#세그먼트-아키텍처)
- `syscall-entry.S`: 시스템 호출 핸들러를 부트스트랩하는 작은 어셈블리 코드. 이 코드를 이해할 필요는 없음

## 파일 시스템 사용하기

- filesys 디렉토리에 파일시스템이 구현되어있음
- `filesys.h` 및 `file.h` 참고하되 수정할 필요는 없음
- 제한 사항
    - 내부 동기화 없음: 한 번에 하나의 프로세스만 파일 시스템 코드를 실행하도록 구현해야함
    - 파일 크기는 생성 시 고정: 루트 디렉토리가 파일로 표현되므로 생성할 수 있는 파일 수도 제한.
    - 파일 데이터는 단일 익스텐트(extent)로 할당: 단일 파일의 데이터는 디스크의 연속적인 섹터 범위를 차지해야 함. -> 외부 단편화가 심해질 수 있음
    - 하위 디렉토리 없음
    - 파일 이름은 14자로 제한
    - 작업 중 시스템 충돌 시 손상될 수 있으며 파일 시스템 복구 도구는 없음.
- 주요 특징
    - `filesys_remove()`
        - UNIX와 유사 파일이 열려 있는 동안 제거되면, 해당 블록은 할당 해제되지 않으며 마지막으로 닫는 스레드까지 해당 파일을 열어둔 모든 스레드에서 계속 접근할 수 있음
        - 참고: [열린 파일 제거](#열린-파일-제거)

### 프로그램을 Pintos 가상 머신에 넣기

- 파일 시스템 파티션이 있는 디스크를 생성하고, 파일 시스템을 포맷하고, 이 프로젝트의 두 번째 테스트 케이스인 args-single 프로그램을 새 디스크에 복사한 다음, 'onearg' 인수를 전달하여 실행하는
  방법의 요약
- `userprog/build` 에서
- `pintos-mkdisk filesys.dsk 10`
- `pintos --fs-disk filesys.dsk -p tests/userprog/args-single:args-single -- -q -f run 'args-single onearg'`

## 사용자 프로그램 작동 방식

- Pintos는 일반 C 프로그램을 실행할 수 있으나, 메모리에 맞고 여러분이 구현할 시스템 호출만 사용하는 경우에 해당
- 시스템 호출 중 메모리 할당을 허용하는 것이 없으므로 malloc()은 구현할 수 없음
- 부동 소수점 연산을 사용하는 프로그램은 실행할 수 없음
- `userprog/process.c`에 제공된 로더로 ELF 실행 파일을 로드할 수 있음

## 가상 메모리 레이아웃

- 가상 메모리는 사용자 가상 메모리와 커널 가상 메모리의 두 영역으로 나뉨
    - 사용자 가상 메모리
        - 가상 주소: 0 ~ `KERN_BASE`
            - `KERN_BASE`: `include/threads/vaddr.h`에 정의 / 기본값은 `0x8004000000`
        - 사용자 가상 메모리는 프로세스 별로 할당됨.
        - 따라서 프로세스 별로 페이지 테이블을 가지고 있고, 그걸 모아둔 것이 페이지 디렉토리
        - 각각의 페이지 디렉토리 엔트리에는 페이지 테이블의 첫주소를 가지고 있음.
        - 프로세스를 전환할 때는 CR3 레지스터라는 특별한 레지스터에 해당하는 프로세스의 페이지 디렉터리 주소를 넣어줘야함.
        - `struct thread`는 프로세스의 페이지 테이블에 대한 포인터를 포함
    - 커널 가상 메모리
        - 가상 주소: `KERN_BASE` ~
            - 물리 메모리와 1:1 매핑
                - `KERN_BASE`: 물리주소 0
                - `KERN_BASE + 0x1234`: 물리주소 0x1234
            - 시스템의 물리 메모리 크기까지 계속됨.
        - 전역적임. 어떤 사용자 프로세스나 커널 스레드가 실행중인지에 관계없이 항상 동일한 방식으로 매핑됨.
    - 사용자 프로그램은 자신의 사용자 가상 메모리만 접근 할 수 있어야함.
        - 커널 가상 메모리에 접근하려고 시도하면 페이지 폴트 발생 후 프로세스 종료 -> `userprog/exception.c`의 `page_fault()`에 의해 처리
    - 커널 스레드
        - 커널 가상 메모리 접근 가능
        - 사용자 프로세스가 실행 중인 프로세스의 사용자 가상 메모리 접근 가능
        - 물리 메모리와 매핑되지 않은 사용자 가상 주소의 메모리에 접근하려고 시도하면 페이지 폴트가 발생

## 전형적인 메모리 레이아웃

- 사용자 가상메모리 레이아웃

```
USER_STACK +----------------------------------+
           |             user stack           |
           |                 |                |
           |                 |                |
           |                 V                |
           |           grows downward         |
           |                                  |
           |                                  |
           |                                  |
           |                                  |
           |           grows upward           |
           |                 ^                |
           |                 |                |
           |                 |                |
           +----------------------------------+
           | uninitialized data segment (BSS) |
           +----------------------------------+
           |     initialized data segment     |
           +----------------------------------+
           |            code segment          |
 0x400000  +----------------------------------+
           |                                  |
           |                                  |
           |                                  |
           |                                  |
           |                                  |
       0   +----------------------------------+
```

- project2까지는 스택 크기 고정
- **링커**: 링커 스크립트의 지시에 따라 메모리 내 사용자 프로그램의 레이아웃을 설정
- **링커 스크립트**: 세그먼트의 이름과 위치를 링커에게 알려줌

## 사용자 메모리 접근

- 커널은 시스템 호출의 일부로서 사용자 프로그램이 제공한 포인터를 통해 메모리에 접근해야하는 경우가 맍음
- 사용자가 NULL 포인터, 매핑되지 않은 가상메모리를 가리키는 포인터, 커널 가장 주소공간을 가리지큰 포인터를 전달 할 수 있음
- 처리 방법 두 가지
    1. 유효성 검증 후, 역참조(derefernce)

    - `thread/mmu.c`, `include/threads/vaddr/h` 참조.
    - 가장 **간단한** 방법

    2. 사용자 포인터가 `KERN_BASE` 보다 아래를 가리키는지 확인한 다음 바로 역참조하는 것.

    - 유효하지 않은 사용자 포인터는 페이지 폴트를 유발하며, 이는 `userprog/exception.c`의 `page_fault()` 코드를 수정하여 처리
    - 프로세서의 MMU(메모리 관리 장치)를 활용 -> 일반적으로 빠르고 실제로 주로 사용됨
- [리소스 누수](#리소스-누수)가 발생하지 않도록 주의해야함.

### 2번 방법에 대한 유용한 코드

```c
/* 사용자 가상 주소 UADDR의 한 바이트를 읽습니다.
* UADDR은 KERN_BASE 미만이어야 합니다.
* 성공하면 바이트 값을 반환하고, 세그멘테이션 폴트가 발생하면 -1을 반환합니다. */
  static int64_t get_user (const uint8_t *uaddr) {
  int64_t result;
  __asm __volatile (
  "movabsq $done_get, %0\n" // done_get 레이블의 주소를 result에 저장
  "movzbq %1, %0\n"         // *uaddr에서 한 바이트를 읽어 0으로 확장하여 result에 저장
  "done_get:\n"             // done_get 레이블
  : "=&a" (result) : "m" (*uaddr)); // result는 %rax, *uaddr는 메모리 operand
  return result;
  }

/* 사용자 주소 UDST에 BYTE를 씁니다.

* UDST는 KERN_BASE 미만이어야 합니다.
* 성공하면 true를 반환하고, 세그멘테이션 폴트가 발생하면 false를 반환합니다. */
  static bool put_user (uint8_t *udst, uint8_t byte) {
  int64_t error_code;
  __asm __volatile (
  "movabsq $done_put, %0\n" // done_put 레이블의 주소를 error_code에 저장
  "movb %b2, %1\n"         // byte의 하위 8비트를 *udst에 쓴다
  "done_put:\n"            // done_put 레이블
  : "=&a" (error_code), "=m" (*udst) : "q" (byte)); // error_code는 %rax, *udst는 메모리 operand, byte는 레지스터/메모리 operand
  return error_code != -1;
  }
```

- 모두 사용자 주소가 이미 KERN_BASE 미만임을 검증했다고 가정한 함수들임.
- `page_fault()` 수정해, 커널에서 페이지 폴트가 발생하면 단순히 rax를 -1로 설정하고 이전 값을 %rip에 복사하도록 했다고 가정

# Argument Passing

- `process_exec()`에서 사용자 프로그램의 인자 설정하기

## x86-64 호출 규약 (Calling Convention)

1. 사용자 수준 애플리케이션은 인자 전달을 위해 정수 레지스터를 사용 -> `%rdi`, `%rsi`, `%rdx`, `%rcx`, `%r8`, `%r9` (순서 주의)
2. caller는 다음 명령어 주소를 스택에 푸시 -> 돌아오기 위해서
3. callee의 첫번째 명령어로 점프 -> 2번과 3번을 `CALL` 명령어로 수행
4. callee 실행 후 반환값이 있다면 `%rax` 레지스터에 저장
5. callee는 스택에서 반환주소를 pop 하고 `RET` 명령어를 통해 해당 주소로 점프

- ex) `f(1,2,3)`에 대해 4번 실행에서 callee가 보는 상채
    - `stack pointer -> 0x4747fe70: return address`
    - `RDI: 0x0000000000000001 | RSI: 0x0000000000000002 | RDX: 0x0000000000000003`

## 프로그램 시작 상세 정보

- `lib/user/entry.c`의 [`_start()`](#`start()`)가 사용자 프로그램의 **진입점**.
- 사용자 프로그램 실행 전, **초기 함수의 인자들을 레지스터에 넣어야함.**
- 명령어 인자 처리 방법 -> `/bin/ls -l foo bar`
    1. 명령어를 단어 단위로 분리: `/bin/ls`, `-l`, `foo`, `bar` -> 모두 `argv`의 요소들임
    2. 단어들을 스택 맨위에 배치 -> 순서 상관없음
    3. 2번의 주소(포인터)들을 다시 스택에 push해서 `argv` 배열 구성

    - 주의할 점
        - `argv[0] = /bin/ls`이 스택의 가장 낮은 주소여야하며 순서대로 올라가야함.
        - `argv[argc] == NULL`
        - 첫 푸시 전에 워드 정렬을 위해 8의 배수로 내림하여 정렬하기

    4. `%rsi` = `argv`의 주소 / `%rdi` = `argc`
    5. 스택에 가짜 "반환 주소"를 푸시 -> 다른 함수와 동일한 구조를 가지기 위해.

| Address    | Name           | Data        | Type        |
|------------|----------------|-------------|-------------|
| 0x4747fffc | argv[3][...]   | 'bar\0'     | char[4]     |
| 0x4747fff8 | argv[2][...]   | 'foo\0'     | char[4]     |
| 0x4747fff5 | argv[1][...]   | '-l\0'      | char[3]     |
| 0x4747ffed | argv[0][...]   | '/bin/ls\0' | char[8]     |
| 0x4747ffe8 | word-align     | 0           | uint8_t[]   |
| 0x4747ffe0 | argv[4]        | 0           | char *      |
| 0x4747ffd8 | argv[3]        | 0x4747fffc  | char *      |
| 0x4747ffd0 | argv[2]        | 0x4747fff8  | char *      |
| 0x4747ffc8 | argv[1]        | 0x4747fff5  | char *      |
| 0x4747ffc0 | argv[0]        | 0x4747ffed  | char *      |
| 0x4747ffb8 | return address | 0           | void (*) () |

> RDI: 4 | RSI: 0x4747ffc0

## 인자 전달 구현하기

- 현재 `process_exec()`: 인자 전달 지원 x
- f_name -> 공백을 통해 구분
    - 1: 프로그램 이름
    - 2: 첫 번째 인자
    - 3: 두 번째 인자
    - ...
- 명령줄 인자의 길이에 합리적인 제한을 둘 수 있음
    - 제한 하려면 4KB 정도로
    - 필수는 아니며, 이미 커널에 전달되는 명렬줄 자체의 길이가 128바이트로 제한됨.
- 참고
    - `include/lib/string.h`에 프로토 타입
    - `lib/string.c`에 `strtok_r()`

# 추가 정보

## 세그먼트 아키텍처

- 메모리를 여러 개의 논리적인 섹션, 즉 세그먼트(segments)로 나누어 관리하는 방식
- 각 세그먼트는 특정 유형의 정보를 담도록 설계되며, 예를 들어 코드 세그먼트, 데이터 세그먼트, 스택 세그먼트 등으로 나눌 수 있음
- 메모리에 접근할 때:  **세그먼트 레지스터(segment register)**와 **오프셋(offset)**의 조합을 사용
    - 세그먼트 레지스터: 현재 접근하려는 메모리가 어떤 세그먼트에 속하는지를 가리키는 역할. 고유한 시작 주소와 크기가 있음
    - 오프셋: 세그먼트의 시작 주소로부터 실제 데이터가 있는 위치까지의 상대적인 거리

## 열린 파일 제거

- https://casys-kaist.github.io/pintos-kaist/project2/FAQ.html

## 리소스 누수

- 프로그램이 할당받은 컴퓨터 자원(resource)을 사용한 뒤 제대로 해제하지 않아서, 그 자원이 계속해서 시스템에 묶여 다른 프로그램이나 시스템 자체가 사용할 수 없게 되는 현상
- 메모리:  malloc 같은 함수를 통해 메모리를 할당받은 후, free를 호출하여 해제하지 않는 경우
- 파일 핸들: 파일을 열어서 작업한 후 close 함수로 닫지 않는 경우
- 락/뮤텍스: 락 획득 후 락을 해제하지 못한 경우
- 스레드/프로세스: 자식 스레드나 프로세스를 생성 후 제대로 종료시키거나 자원을 회수 하지 않는 경우.

## `_start()`

- Pintos 사용자 프로그램의 실제 시작 지점
- `main()` 함수 호출
    - 커널은 `argc`와 `argv` 값을 미리 준비해서 `_start()` 함수에 전달
    - `_start()`는 그걸 `main(argc, argv)`로 넘겨줌
- `exit()` 호출
    - `main(argc, argv)`의 반환 값(종료 상태)을 `exit()` 함수의 인자로 전달
        - `0`: 정상 종료
        - 이외: 오류
    - `exit()`는
        - 시스템 호출(system call)을 통해 커널에 종료 상태를 전달
        - 프로그램이 사용하던 모든 시스템 자원(열린 파일, 할당된 메모리 등)을 정리하고 해제하는 데 도움을 줌